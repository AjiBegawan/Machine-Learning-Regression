# -*- coding: utf-8 -*-
"""SleepEfficiency_V6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hZk5kVUWOBBIFhw8MziO5vcpNIJ5evcT

# Import Library
"""

import math
import numpy as np
import pandas as pd
import seaborn as sns
import tensorflow as tf
import matplotlib.pyplot as plt

from tensorflow import keras
from tensorflow.keras.models import Sequential, Model
from tensorflow.keras.layers import Dense, Flatten, Conv1D, MaxPooling1D, LSTM, GRU, Input

from sklearn.svm import SVR
from sklearn.tree import DecisionTreeRegressor
from sklearn.neural_network import MLPRegressor
from sklearn.neighbors import KNeighborsRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.linear_model import LinearRegression, Lasso, Ridge, ElasticNet
from sklearn.ensemble import RandomForestRegressor, AdaBoostRegressor, GradientBoostingRegressor

"""# Data Loading """

df = pd.read_csv("../../SleepEfficiency/Dataset/Sleep_Efficiency.csv")

"""# Inital Analysis"""

new_columns = ['id', 'age', 'gender','bed_time', 'wakeup_time', 'sleep_dur', 'sleep_eff', 'rem_per', 'deep_per', 'light_per', 'awake',
               'caffeine', 'alcohol', 'smoke_stat', 'exercise_freq']
df.columns = new_columns
df = df.drop(columns=['id','bed_time', 'wakeup_time'])
df.sample(5)

print(df.info())
df.describe()

"""### Split Numerical and Categorical Columns (1)"""

numerical_columns = [column for column in df.columns if df[column].dtype != 'object']
print(numerical_columns)

categorical_columns = [column for column in df.columns if df[column].dtype == 'object']
print(categorical_columns)

"""### Fill Null Value"""

def set_fillna(df, numerical_columns):
    df[numerical_columns] = df[numerical_columns].fillna(df[numerical_columns].mean())
    return df

df = set_fillna(df, numerical_columns)

"""### Change Columns Dtypes"""

def set_types(df):
    df['age']           = df['age'].astype('int8')
    df['gender']        = df['gender'].astype('category')
    df['sleep_dur']     = df['sleep_dur'].astype('float16')
    df['sleep_eff']     = df['sleep_eff'].astype('float16')
    df['rem_per']       = df['rem_per'].astype('int8')
    df['deep_per']      = df['deep_per'].astype('int8')
    df['light_per']     = df['light_per'].astype('int8')
    df['awake']         = df['awake'].astype('int8')
    df['caffeine']      = df['caffeine'].astype('int8')
    df['alcohol']       = df['alcohol'].astype('int8')
    df['smoke_stat']    = df['smoke_stat'].map({'Yes': 1, 'No':0}).astype('int8')
    df['exercise_freq'] = df['exercise_freq'].astype('int8')
    return df

df = set_types(df)

"""### Split Numerical and Categorical Columns (2)"""

numerical_columns = [column for column in df.columns if df[column].dtype != 'category']
print(numerical_columns)

categorical_columns = [column for column in df.columns if df[column].dtype == 'category']
print(categorical_columns)

"""# Data Exploration """

num_rows = 3
num_cols = math.ceil(len(numerical_columns) / num_rows)

fig, axes = plt.subplots(num_rows, num_cols, figsize=(20, 10))
for i, column in enumerate(numerical_columns):
    row = i // num_cols
    col = i % num_cols
    sns.kdeplot(data=df, x=column, ax=axes[row, col]).set_title("Distribusi nilai kolom " + column)
    
for i in range(len(numerical_columns), num_rows * num_cols):
    row = i // num_cols
    col = i % num_cols
    axes[row, col].axis('off')

plt.tight_layout()
plt.show()

for column in categorical_columns:
    plt.figure(figsize=(5,3))
    sns.countplot(x=df[column]).set_title("Perbandingan Laki-laki dan Perempuan")
    plt.show()

num_rows = 3
num_cols = math.ceil(len(numerical_columns) / num_rows)

fig, axes = plt.subplots(num_rows, num_cols, figsize=(20, 10))
for i, column in enumerate(numerical_columns):
    row = i // num_cols
    col = i % num_cols
    sns.kdeplot(data=df, x=column, hue="gender", fill=True, alpha=.2, palette="crest", ax=axes[row, col]).set_title("Distribusi nilai kolom " + column)
    
for i in range(len(numerical_columns), num_rows * num_cols):
    row = i // num_cols
    col = i % num_cols
    axes[row, col].axis('off')

plt.tight_layout()
plt.show()

num_rows = 2
num_cols = math.ceil(len(numerical_columns) / num_rows)
fig, axes = plt.subplots(num_rows, num_cols, figsize=(20, 5))
for i, column in enumerate(numerical_columns):
    row = i // num_cols
    col = i % num_cols
    sns.boxplot(x=df[column], ax=axes[row, col], palette="Blues").set_title("Rentang nilai kolom " + column)
    
for i in range(len(numerical_columns), num_rows * num_cols):
    row = i // num_cols
    col = i % num_cols
    axes[row, col].axis('off')

plt.tight_layout()
plt.show()

"""# Data Correlation"""

corr_matrix = df[numerical_columns].corr().round(2)

plt.figure(figsize=(20, 7))
sns.heatmap(data=corr_matrix, annot=True, cmap='YlGnBu', linewidths=0.5, )
plt.title("Correlation Matrix untuk Fitur Numerik ", size=20)

"""# Data Preprocessing"""

X = df[numerical_columns].drop(columns='sleep_eff')
Y = df['sleep_eff']

# scaler = StandardScaler()
scaler = MinMaxScaler()
X = scaler.fit_transform(X)

X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size = 0.15, random_state = 42)

print(f'Total # of sample in whole dataset: {len(X)}')
print(f'Total # of sample in train dataset: {len(X_train)}')
print(f'Total # of sample in test dataset: {len(X_test)}')

"""# Model Prediction using Regression Algorithms

### Finding optimal parameter for Regression Algorithms
"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# mse_value = []
# r2_value = []
# n_number = 20
# for i in range(n_number):
#     model = KNeighborsRegressor(n_neighbors=i+1)
#     model.fit(X_train, y_train)
#     y_pred = model.predict(X_test).astype('float16')
#  
#     # Calculate the mean squared error (MSE) and the R-squared score
#     mse = mean_squared_error(y_test, y_pred)
#     mse_value.append(mse)
#     r2 = r2_score(y_test, y_pred)
#     r2_value.append(r2)
# 
# # Create a figure and axis
# plt.figure(figsize=(22, 3))
# plt.plot(range(1, n_number+1), r2_value)
# plt.title('R-Square Scores')
# plt.xlabel('Number of Iteration')
# plt.ylabel('Score')
# plt.show()

"""### Regression Algorithms Model Preparation"""

def regression_algorithms():
    algorithms = [
                  ('Linear Regression', LinearRegression()), 
                  ('Lasso Regression', Lasso(alpha=0.0001)),
                  ('Ridge Regression', Ridge(alpha=0.1)),
                  ('ElasticNet Regression', ElasticNet(alpha=0.001, l1_ratio=0.1)),
                  ('SVR', SVR(kernel='rbf')), 
                  ('KNN', KNeighborsRegressor(n_neighbors=10)), 
                  ('Decision Tree', DecisionTreeRegressor(max_depth=14)),
                  ('Gradient Boosting', GradientBoostingRegressor(n_estimators=30, learning_rate=0.1, random_state=42)),
                  ('MLP',MLPRegressor(hidden_layer_sizes=(9000,), max_iter=100, random_state=42)),
                  ('Rendom Forrest', RandomForestRegressor(n_estimators=100, max_depth=10)),
                  ]
    return algorithms

def prepare_regression_model(algorithm):
    model = algorithm
    model.fit(X_train, y_train.values.ravel())
    return model

def calculate_regression_performance(model, X_train, y_train, X_test, y_test):
    y_pred = model.predict(X_test)
    acc = round(model.score(X_train,y_train), 4)*100
    mse = round(mean_squared_error(y_test, y_pred), 4)
    r2  = round(r2_score(y_test, y_pred), 4)

    return acc, mse, r2

def regression_result(result, name, acc, mse, r2):
    result.append((name, acc, mse, r2))
    return result

"""### Regression Algorithms Model Training"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# result = []
# trained_models = []
# 
# algorithms = regression_algorithms()
# 
# for index, tup in enumerate(algorithms):
#     model = prepare_regression_model(tup[1])
#     trained_models.append((tup[0],model))
# 
#     # Calculate the Accuracy, Mean Squared Error (MSE), and R-squared score
#     acc, mse, r2= calculate_regression_performance(model,X_train, y_train, X_test, y_test)
#     result = regression_result(result, tup[0], acc, r2, mse)
# 
# regression_results_df = pd.DataFrame(result, columns=('Model Name', 'Accuracy', 'R-Square', 'MSE'))
# regression_results_df

"""# Model Prediction using Neural Network Algorithms

### Neural Network Algorithms Model Preparation
"""

def DNN_Model():
    dnn_model = Sequential()
    dnn_model.add(Dense(512, activation='relu', input_shape=(X_train.shape[1],)))
    dnn_model.add(Dense(32, activation='relu'))
    dnn_model.add(Dense(1, activation='sigmoid'))
    dnn_model._name = 'DNN_Model'
    return dnn_model

def CNN_Model():
    cnn_model = Sequential()
    cnn_model.add(Conv1D(2048, 2, activation='relu', input_shape=(X_train.shape[1], 1)))
    cnn_model.add(MaxPooling1D(pool_size=2))
    cnn_model.add(Flatten())
    cnn_model.add(Dense(1, activation='sigmoid'))
    cnn_model._name = 'CNN_Model'
    return cnn_model

def LSTM_Model():
    lstm_model = Sequential()
    lstm_model.add(LSTM(units=32, input_shape=(X_train.shape[1], 1)))
    lstm_model.add(Dense(units=1))
    lstm_model._name = 'LSTM_Model'
    return lstm_model

def GRU_Model():
    gru_model = Sequential()
    gru_model.add(GRU(units=32, input_shape=(X_train.shape[1], 1)))
    gru_model.add(Dense(units=1))
    gru_model._name = 'GRU_Model'
    return gru_model

def Autoencoder_Model():
    # define the input shape and input layer
    input_shape = (X_train.shape[1],)
    input_layer = Input(shape=input_shape)
    encoded_layer = Dense(256, activation='relu')(input_layer)
    encoded_layer = Dense(64, activation='relu')(encoded_layer)
    decoded_layer = Dense(16, activation='relu')(encoded_layer)
    decoded_layer = Dense(input_shape[0], activation='sigmoid')(decoded_layer)

    # define the Autoencoder model
    autoencoder_model = Model(input_layer, decoded_layer)
    autoencoder_model._name = 'Autoencoder_Model'

    # compile the Autoencoder model and fit the Autoencoder model to the data
    autoencoder_model.compile(optimizer='adam', loss='mse', metrics=['mse', 'mae'])
    autoencoder_model.fit(X_train, X_train, epochs=100, batch_size=64, validation_data=(X_test, X_test), verbose=0)
    return autoencoder_model

def NN_Algorithms():
    nn_algorithms = [
        ('DNN', DNN_Model()),
        ('CNN', CNN_Model()),
        ('LSTM', LSTM_Model()),
        ('GRU', GRU_Model()),
        ('Autoencoder', Autoencoder_Model())
    ]
    return nn_algorithms
    
def compile_train_model(model, X_train, y_train, X_test, y_test):
    model.compile(optimizer='adam', loss='mse')
    model.fit(X_train, y_train, epochs=100, batch_size=64, validation_data=(X_test, y_test), verbose=0)
    return model 

def evaluate_model(model, X_test, y_test):
    acc = 'null'
    y_pred  = model.predict(X_test)

    if(model._name == 'Autoencoder_Model'):
      r2  = round(r2_score(X_test, y_pred), 4)
      mse = round(mean_squared_error(X_test, y_pred), 4)
    else:
      r2  = round(r2_score(y_test, y_pred), 4)
      mse = round(mean_squared_error(y_test, y_pred), 4)
    return acc, mse, r2

def NN_result(result, name, acc, r2, mse):
    result.append((name, acc, r2, mse))
    return result

"""### Neural Network Algorithms Model Training"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# result = []
# 
# algorithms = NN_Algorithms()
# 
# for index, model in enumerate(algorithms):
#     print(model[0])
#     if(model[0] == 'Autoencoder'):
#         nn_model = model[1]
#     else:    
#         nn_model = compile_train_model(model[1], X_train, y_train, X_test, y_test)
#         
#     acc, mse, r2= evaluate_model(nn_model, X_test, y_test)
#     result = NN_result(result, model[0], acc, r2, mse)
#     print('=' * 100)
#     
# nn_results_df = pd.DataFrame(result, columns=('Model Name', 'Accuracy', 'R-Square', 'MSE'))
# nn_results_df